# 1. 微服务概念精粹

## 1.1 微服务的核心特点

**作用：**微服务的设计一定要围绕微服务的核心特点进行，否则都不是一个合理的微服务设计

**核心特点：**

- 独立部署：反模式包括共享数据库，分布式的大单体
- 面向业务领域建模：微服务首先是业务逻辑上的高内聚、低耦合，然后才是业务逻辑内的工程实现上的高内聚、低耦合（人人都是产品经理）

注：

- 独立部署是我们追求的目标，面向业务领域建模是独立部署的前提；
- 独立部署可以更快的发布产品，面向业务领域建模可以控制业务功能变更的范围；
- 独立部署是区别于单体应用的核心特点（单体应用指应用的部署单元）
- 偶合包括**实现偶合**和**部署偶合**

## 1.2 微服务解决的问题和带来的新问题

> 根据业务目标（包含业务愿景）和组织的能力，结合微服务的优缺点来决策微服务架构是否适合。

**微服务解决的问题：**

- 提高团队治理能力：一个微服务通过对应7~12个人，通过赋予权利和责任，可以让小团队趋于自治，充分调动团队成员的积极性。 
- 缩短业务发布时间：这里主要指业务特性从开始开发到发布上线时间，此外这要依赖于服务的独立部署和发布单元
- 支持技术异构：根据业务特点为服务选择合适的技术栈或迁移到新的技术
- 合理的资源使用：可以精准的对具体的微服务进行缩容、扩容或取消，节省运营成本

注：

除了支持技术异构是微服务特有的优势，其他的优势实际上可以通过其他手段来达到，如在单体中为不同的团队开放不同模块的代码所有权也可以提高团队的治理能力；单体水平扩展+负载均衡也能达到合理利用资源的目的。

**微服务带来的新问题:**

- 增加了运维复杂度：从监控单体应用到监控分布式应用，问题定位变得更复杂
- 增加网络延迟：对于实时性要求高的系统并不适合使用微服务架构，如游戏
- 形成了数据孤岛：微服务并不擅长于解决数据聚合问题
- 如何拆分微服务：微服务拆分的不合理反而会适得其反，如不了解业务领域

## 1.3 接口设计原则

**指导原则：**

- 信息隐藏原则：不要暴露不必要的信息给外界
- 契约原则：接口作为契约，一旦确定，就要少变更或者保证变更的兼容性

注：暴露后再修改就要考虑兼容，反之则没有什么担忧

**设计方法：**

- 由外向内：根据上游服务或微服务自身所处领域的需求设计接口
- 由内向外：接口粒度越来越粗

注：这两个设计方法都是满足信息隐藏原则的

## 1.4 内聚与偶合

在微服务架构下，为了实现独立部署，我们更注重高内聚低耦合。

### 1.4.1 内聚

**定义**：把一同变化的代码放在一块。

**作用**：通过内聚减少变更的范围和成本（沟通成本、业务理解成本、环境搭建成本、发布成本等）

### 1.4.2 偶合

偶合是为了解决某一类问题而导致的。

#### 1.4.2.1 实现偶合

**定义**：服务A在实现时依赖了另一个服务B的内部实现，当服务B改变实现时，导致服务A也需要变更。比如服务A直接使用服务B的数据表。依赖公共的工具包实际上也是一种实现依赖。

**示例**：

<img src="images/microservice/implement_couple.png" alt="img" style="zoom: 33%;" />

**解决方案**：

- 使用Restful API接口作为契约，外部服务调用该接口
- 被依赖服务将数据发布到一个公共的仓库中，由依赖服务使用

#### 1.4.2.2 时间偶合

**定义**：为了完成某个业务功能，需要多个服务接口按时间顺序（或称先后顺序）进行级联访问。

**示例**：

![img](images/microservice/time_couple.png)

**解决方案**：

- 在某一个位置统一编排服务间的接口调用，如BFF
- 采用异步事件的方式解偶服务间的依赖
- 采用缓存提高服务的可用性

#### 1.4.2.3 部署偶合

#### 1.4.2.4 领域偶合

# 2. 微服务迁移规划

> 不要为了微服务而选择微服务架构，**微服务不是我们的目标**。

## 2.1 理清四个问题

- 业务希望实现什么：包括业务愿景
- 是否考虑过除微服务以外的其他方案：调研过的方案对比结果是什么
- 技术团队面临的问题是什么
- 如何知道迁移过程是否有效：避免偏离业务目标

## 2.2 不要偏离核心目标

为了获得更多的变更收益，人们在定目标时，通常会考虑一个以上的目标，比如：

> 业务人员：我们需要让我们的系统支持更大的流量
>
> 开发甲：我们采用微服务吧，微服务是未来的方向，云原生技术也为微服务提供了相应的解决方案
>
> 开发乙：如果采用微服务，我们可以配置全功能的团队，这样团队就可以往自治方向发展
>
> 开发丙：我们还可以切换到新的技术栈，这样可以提升开发效率和团队的技术能力
>
> 开发丁：使用docker+k8s部署，支持服务的自动扩容和综容

为了支持更大的流量，我们额外设定了多个目标：

- 配置全功能团队，提升团队的自治力
- 引入新的技术和部署方式等

过多的导致的问题包括：

- 更长的前置时间：如在开发前需要考虑更多的事项和调研更多的内容
- 短时间内无法看到收益，影响团队士气
- 导致过度复杂的方案：如单体水平扩展可以应对流量增加，却无法引入新的技术

在多目标的决策过程中，需要区分**核心目标和间接收益**。核心目标作为第一优先级实现，如果在实现核心目标的过程中能够在可接受的成本内兼顾间接收益，则更好，如果无法兼顾，则将间接收益后移。尤其当间接收益阻碍核心目标的实现时，更需要后移或放弃间接收益。

## 2.3 微服务迁移的策略

**总策略**：小步迭代，增量迁移，及时发布（最好能发布到生产环境，这样能更早的暴露问题）

**步骤（分而治之的思想）：**

- 将待拆分系统分解成很多小的拆分步骤
- 每个拆分步骤都是可验证的
- 第个拆分步骤完成后及时发布
- 发现问题后，及时学习总结，调整策略，避免后续发生相同的问题

在实施拆分步骤时，建议拆分时先简单后复杂，这样做有以下几个好处：

- 可以及时的看到拆分的成果，鼓舞团队士气，
- 发生问题的影响面小，易修改
- 及早暴露出一些在设计和评估时未考虑到的问题

## 2.4 当不知如何决策时

当做决策的时候，我们经常会在多个方案之间徘徊，反复的分析每个方案的优缺点，希望通过对比来选择一个最合理的方案。然而，最终的结果可能事与愿违，此时我们又会想，假如我们选择了另一个方案是不是就不会有这些问题了。

**我们首先必须承认，在软件的开发开发、优化、变更过程中不可避免的会发生错误，我们应该要拥抱错误。通过在错误中不断的总结学习，我们才能更好的避免错误**。

当不知道如何决策时，我们应该**控制决策回退的成本**。

<img src="images/decision_making_cost.png" alt="image-20220309175817400" style="zoom:50%;" />

- 从可逆决策过度到不可逆决策时，决策回退的成本是在增加的
- 在成本增加的方向上做出决策时，需要考虑的更慎重、投入更多的人等
- 在越靠近可逆决策一端，就越可以由直接面对问题的人做出决策

如果依然无法做出决策，通常的做法是在影响最小的地方试错。

## 2.5 如何合理的拆分微服务

### 2.5.1 正向拆分

采用DDD的方法，利用DDD的工作坊进行战略和战术建模，找到聚合根，划分限界上下文，通过DDD的四层架构将一个或多个限界上下文实现为微服务。

那如何确定限界上下文的优先级呢？

DDD的传统作法是将限界上下文划分成子域，子域又分成通用域、核心域和支撑域，从业务价值出发我们应该将资源优先投入到核心域上。

但是，在从一个已有的系统向微服务迁移的过程中，我们需要考虑的更多，包括：

- 更早的获得方法有效性的反馈
- 迟早的取得进展，提升团队土气
- 迁移的目标

因此，传统的DDD作法并不适合。为了解决该问题，我们建议采用“**难易度-价值四项限法**”，比如对于一个2C的销售订单场景：

<img src="images/microservice/ddd_inbound_context.png" alt="image-20220309213659204" style="zoom:50%;" />

如果我们想应对高峰时期的客户流量，其“难易度-价值四项限”的画法可能是：

<img src="images/microservice/image-20220309215410942.png" alt="image-20220309215410942" style="zoom:50%;" />

因此，我们可能最先迁移出的服务是销售上下文。

然而，当真正的开始工作时，我们可能会遇到很多未考虑到的问题，这时候需要回过头来看我们在开始时制定的策略和方案，对先前的策略和方案进行调整和优化。

### 2.5.2 逆向拆分？

UML+数据表







## 2.1 微服务迁移的关注点

**应该关注什么：**

- 可以处理多少个微服务：决定我们微服务迁移的策略
- 如何划分微服务边界：防止微服务让事情变得一团糟
- 组织架构的调整：减少交付冲突和沟通成本

**不应该关注什么:**

- 技术选型：这是实现层面，而不是决策层面

注：

- 为什么不关注基础设施？因为服务上云的趋势，云会为我们提供相应的能力；
- 为什么不关注团队的能力？可以处理多少个微服务中需要考虑团队的能力，如果服务上云，对团队的能力要求其实就是学习云的操作

# 参考资料

1. https://wangwei1237.github.io/monolith-to-microservices/docs/What_Are_Microservices.html